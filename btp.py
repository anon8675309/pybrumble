#!/usr/bin/env python3
# Python implementation of the Briar Transport Protocol
from constants import TRANSPORT_ID_STRING_LAN
from struct import pack, unpack
from time import time
try:
    from secrets import token_bytes as R
    # Blake2 wasn't added to hashlib in Python 3.4.3 and even later it did not
    # support a digest size of 32 bytes (only 64-byte digests are allowed) there
    from blake256.blake256 import blake_hash as H
    # the cryptography module has ChaCha20Poly1305 but not XsalsaPoly1305
    from Crypto.Cipher import ChaCha20_Poly1305
except ImportError as e:
    print("%s" % e)
    print("To install dependencies: pip3 install pycryptodome blake256")
    from sys import exit
    exit(1)

# Version of the BTP that we are following and constants for that version
PROTOCOL_VERSION = 4;
KEY_LEN = 32
NONCE_LEN = 24
AUTH_LEN = 16

# Maximum difference in the peer's clocks
D = 86400 # 1 day
# Maximum transport latency for TCP
TCP_L = 60    # 1 minute


ALICE_HANDSHAKE_TAG_KEY = b"org.briarproject.bramble.transport/ALICE_HANDSHAKE_TAG_KEY"
ALICE_HANDSHAKE_HEADER_KEY = b"org.briarproject.bramble.transport/ALICE_HANDSHAKE_HEADER_KEY"
BOB_HANDSHAKE_TAG_KEY = b"org.briarproject.bramble.transport/BOB_HANDSHAKE_TAG_KEY"
BOB_HANDSHAKE_HEADER_KEY = b"org.briarproject.bramble.transport/BOB_HANDSHAKE_HEADER_KEY"
ROTATE = b"org.briarproject.bramble.transport/ROTATE"

class BtpStreamHeader(object):
    def BtpStreamHeader(self, stream_number, key, nonce=None, protocol_version=PROTOCOL_VERSION):
        """
        Creates a new stream header

        :param stream_number: index of the stream
        :type stream_number: int
        :param key: ephemeral cipher key to be used for this stream
        :type key: bytes
        :param nonce: The nonce, will be generated by default (when nonce=None)
        :type nonce: bytes
        :param protocol_version: The version of the BTP protocol we are using
        :type protocol_version: int
        """
        # nonce
        self.nonce = R(NONCE_LEN) if nonce is None else nonce
        # stream header
        self.protocol_version = protocol_version
        self.stream_number = stream_number
        self.key = key
        self.ephemeral_cipher_key = None

    def decrypt_and_decode(key, payload):
        """
        Decrypt and decode a payload that was read in off the wire. The payload
        needs to be at least 82 bytes (NONCE_LEN + 2 + 8 + KEY_LEN + AUTH_LEN)
        long in order to be potentially valid, and the authentication tag must
        be valid. An ValueError exception is raise if any of these fail.

        :param key: The incoming header key
        :type key: bytes
        :param payload: the bytes read in off the wire
        :type payload: bytes
        :returns: parsed object, or None if the payload wasn't long enough
        :rtype: :class:`py:BtpStreamHeader`
        """
        if len(payload) < (NONCE_LEN + 2 + 8 + KEY_LEN + AUTH_LEN):
            raise ValueError("Payload not long enough to contain a stream header")
        o = BtpStreamHeader(0, b"")
        o.nonce = payload[0:NONCE_LEN]
        stream_header_plaintext = DEC(key, payload[NONCE_LEN:])
        o.protocol_version = unpack(">I", stream_header_plaintext[0:2])[0]
        o.stream_number = unpack(">Q", stream_header_plaintext[2:2+8])[0]
        o.ephemeral_cipher_key = stream_header_plaintext[2+8:2+8+KEY_LEN]
        return o

    def encode(self, key):
        """
        Outputs the encoded header, suitable for sending over the wire

        :param key: The outgoing header key
        :type key: bytes
        :returns: The none and encrypted header
        :rtype: bytes
        """
        if self.ephemeral_cipher_key is None:
            self.ephemeral_cipher_key = R(KEY_LEN)
        stream_header_plaintext = (pack(">H", self.protocol_version) +
                                   pack(">Q", self.stream_number) +
                                   self.ephemeral_cipher_key)
        return self.nonce + ENC(key, self.nonce, stream_header_plaintext)

def ENC(key, nonce, message):
    """
    Encrypts the message using the key and the nonce. Also adds authentication
    tag, making the output be AUTH_LEN bytes longer than the input.

    :param key: encryption key to be used for this stream
    :type key: bytes
    :param nonce: The nonce to be used for this message
    :type nonce: bytes
    :param message: The message to be signed and authenticated
    :type message: bytes
    :returns: encrypted payload + authentication tag
    :rtype: bytes
    """
    cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)
    ciphertext, tag = cipher.encrypt_and_digest(message)
    return ciphertext + tag

def DEC(key, nonce, message):
    """
    Decrypts the message using the key and the nonce.

    :param key: encryption key to be used for this stream
    :type key: bytes
    :param nonce: The nonce to be used for this message
    :type nonce: bytes
    :param message: The message to be decrypted with the tag appended (tag is
                    expected to be AUTH_LEN bytes long)
    :type message: bytes
    :returns: decrypted message
    :rtype: bytes
    """
    tag = message[-AUTH_LEN:]
    message = message[0:-AUTH_LEN]
    cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)
    plaintext = cipher.decrypt_and_verify(message, tag)
    return plaintext

def PRF(k, m):
    """
    Pseudorandom function (PRF) implemented as defined in section 2.2 of the BTP
    specification.

    :param k: Secret key
    :type k: bytes
    :param m: Message
    :type m: bytes
    :returns: pseudo-random, but deterministic, bytes
    :rtype: bytes
    """
    return H(k + m)

def KDF(k, m):
    """
    Key derivation function (KDF) implemented as defined in section 2.2 of the
    specification.

    :param k: Secret key
    :type k: bytes
    :param m: Messages
    :type m: list
    :returns: key material
    :rtype: bytes
    """
    total_message = b""
    for i in m:
        total_message += pack(">I", len(i)) + i
    return PRF(k, total_message)

def initial_keys(root_key, transport_id, i_am_alice):
    """
    Implements initial key derivation for rotational mode, as described in
    section 2.4 of the spec. These should be considered to be the key of the
    previous timeperiod (P-1). They can be rotated once to obtain the keys for
    the current time period. After the initial keys are established, the root
    key must be discarded.

    :param root_key: Root key
    :type root_key: bytes
    :param transport_id: a string identifying which transport to use
    :type transport_id: binary string
    :param i_am_alice: Flag indicating if the caller's role is of Alice
    :type i_am_alice: bool
    :returns: Tuple of keys: outgoing tag, outgoing header, incoming tag,
              incoming header
    :rtype: 4 element tuple, all elements are bytes
    """
    if i_am_alice:
        outgoing_tag_key = KDF(root_key, [ALICE_HANDSHAKE_TAG_KEY, transport_id])
        outgoing_header_key = KDF(root_key, [ALICE_HANDSHAKE_HEADER_KEY, transport_id])
        incoming_tag_key = KDF(root_key, [BOB_HANDSHAKE_TAG_KEY, transport_id])
        incoming_header_key = KDF(root_key, [BOB_HANDSHAKE_HEADER_KEY, transport_id])
    else:
        outgoing_tag_key = KDF(root_key, [BOB_HANDSHAKE_TAG_KEY, transport_id])
        outgoing_header_key = KDF(root_key, [BOB_HANDSHAKE_HEADER_KEY, transport_id])
        incoming_tag_key = KDF(root_key, [ALICE_HANDSHAKE_TAG_KEY, transport_id])
        incoming_header_key = KDF(root_key, [ALICE_HANDSHAKE_HEADER_KEY, transport_id])

    return outgoing_tag_key, outgoing_header_key, incoming_tag_key, incoming_header_key

def get_time_period(transport_id, t=None):
    """
    Returns the current timeperiod for the given transport.

    :param transport_id: The transport ID
    :type transport_id: binary string
    :param t: unix timestamp
    :type t: int
    :returns: The timeperiod we are currently in
    :rtype: int
    """
    timestamp = time() if t == None else t
    if transport_id == TRANSPORT_ID_STRING_LAN:
        return int(timestamp/(D+TCP_L))
    raise NotImplemented("Transport %s is not yet implemented" % transport_id.decode())

def rotate_keys(otk, ohk, itk, ihk, P):
    """
    Rotates the keys to obtain the keys for the next timeperiod. The caller
    should discart old keys as soon as they are no longer needed.

    :param otk: Outgoing tag key
    :type otk: bytes
    :param ohk: Outgoing header key
    :type ohk: bytes
    :param itk: Incoming tag key
    :type itk: bytes
    :param ihk: Incoming header key
    :type ihk: bytes
    :param P: Time period for which we are establishing keys
    :type P: int
    :returns: Tuple of keys: outgoing tag, outgoing header, incoming tag,
              incoming header
    :rtype: 4 element tuple, all elements are bytes
    """
    outgoing_tag_key = KDF(otk, [ROTATE, pack(">Q", P)])
    outgoing_header_key = KDF(ohk, [ROTATE, pack(">Q", P)])
    incoming_tag_key = KDF(itk, [ROTATE, pack(">Q", P)])
    incoming_header_key = KDF(ihk, [ROTATE, pack(">Q", P)])

    return outgoing_tag_key, outgoing_header_key, incoming_tag_key, incoming_header_key 

def handshake_mode(root_key, P, transport_id, i_am_alice):
    """
    Implements handshake mode, as described in section 2.5 of the spec.

    :param root_key: Root key
    :type root_key: bytes
    :param P: Time period for which we are establishing keys
    :type P: int
    :param transport_id: a string identifying which transport to use
    :type transport_id: binary string
    :param i_am_alice: Flag indicating if the caller's role is of Alice
    :type i_am_alice: bool
    :returns: Tuple of keys: outgoing tag, outgoing header, incoming tag,
              incoming header
    :rtype: 4 element tuple, all elements are bytes
    """
    if i_am_alice:
        outgoing_tag_key = KDF(root_key, [ALICE_HANDSHAKE_TAG_KEY, transport_id, pack(">Q", P)])
        outgoing_header_key = KDF(root_key, [ALICE_HANDSHAKE_HEADER_KEY, transport_id, pack(">Q", P)])
        incoming_tag_key = KDF(root_key, [BOB_HANDSHAKE_TAG_KEY, transport_id, pack(">Q", P)])
        incoming_header_key = KDF(root_key, [BOB_HANDSHAKE_HEADER_KEY, transport_id, pack(">Q", P)])
    else:
        outgoing_tag_key = KDF(root_key, [BOB_HANDSHAKE_TAG_KEY, transport_id, pack(">Q", P)])
        outgoing_header_key = KDF(root_key, [BOB_HANDSHAKE_HEADER_KEY, transport_id, pack(">Q", P)])
        incoming_tag_key = KDF(root_key, [ALICE_HANDSHAKE_TAG_KEY, transport_id, pack(">Q", P)])
        incoming_header_key = KDF(root_key, [ALICE_HANDSHAKE_HEADER_KEY, transport_id, pack(">Q", P)])

    return outgoing_tag_key, outgoing_header_key, incoming_tag_key, incoming_header_key

def calculate_tag(key, i):
    """
    Calculates the tag for the ith stream associated with the given key. If an
    outgoing tag key is used, it'll generate the outgoing tag. To generate the
    corresponding incoming tag key, pass in the incoming tag key (which is the
    same key as your peer's outgoing tag key.

    :param key: Tag key used to generate the key
    :type key: bytes
    :param i: the index of what stream is being used
    :type i: int
    :returns: The tag for the specified key and stream index
    :rtype: bytes
    """
    return PRF(key, pack(">H", PROTOCOL_VERSION) + pack(">Q", i))
